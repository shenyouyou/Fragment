explain关键字的使用
   语法：explain sql语句；（explain select * from tb；）
   各字段说明：
   1. id: 编号
      1) id值相同，从上往下，顺序执行
         表的执行顺序，因数据的个数改变而改变（原因：笛卡儿积），数据量小的表优先查询。
      2) id值不同，id值越大越优先执行（本质：嵌套子查询时，先查内层，再查外层）。
      3) 子查询+多表：id值有相同，又有不同，id值越大越优先；id值相同，从上往下顺序执行。
         
   2. select_type: 查询类型
      PRIMARY:包含子查询SQL中的主查询（最外层查询）
      SUBQUERY:包含子查询SQL中的子查询（非最外层查询）
      simple：简单查询，不包含子查询、union
              如：from select * from course where tid in (1,2)) cr 
      derived：衍生查询，查询的时候用到的临时表
               1) 在from子查询中，有且只有一张表
                   如：explain select cr.cname from (select * from course where tid in (1,2)) cr
                       上述SQL中子查询的结果集cr就是一张临时表
                       
               2) 在from子查询中，如果有table1 union table2，则table1就是derived，table2就是union
                  explain select cr.cname from (select * from course where tid =1 union select * from course where tid =2)) cr
               union result：告知开发人员，哪些表之间存在union查询
   
   3. table: 指明查询的表
   4. type: 索引类型(有索引的前提下，才能对type进行优化)
            system >const >eq_ref >ref >range >index >all
            其中，system，const只是理想情况；实际能达到级别ref>range
            1) system:只有一条数据的系统表； 或 衍生表只有一条数据的主查询。
            2) const：仅仅能查到一条数据的SQL，用于Primary key或unique索引
                      如：select tid from table1 where tid =1;
            3) eq_ref：唯一性索引，对于每个索引键的查询，返回匹配唯一行数据.
                       查询的结果集和系统表数据能一对一对应。(不会出现一对多或者对应不上)
                       select....from...where...name =...常见于唯一索引和主键索引
                       select t.tcid from teacher t,teacherCard tc where t.tcid=tc.tcid;
                       上述sql用到的索引时t.tcid,即teacher表中的tcid(外键)字段，如果teacher表的数据个数和连接查询的数据个数一致，则有可能达到
            4) ref：非唯一性索引，对于每个索引键的查询，返回匹配的所有行，（0行或多行）。
                    例：explain select * from teacher where tname='章子怡'；（已设置tname为索引列）
            5) range: 检索指定范围的行，where后面时一个范围查询（beween，> <>=,in,注意：in有时候会失效，从而转为无索引all）
                      例：alter table teacher add index tid_index(tid);新增tid列为索引列
                          explain select t.* from teacher t where t.tid in (1,2);
                          explain select t.* from teacher t where t.tid<3;
            6) index：查询全部索引中数据。
                      explain select tid from teacher;(tid是索引列，只需要扫描索引表，不要所有表中的所有数据)
            7) all: 查询全部表中数据。
   
   5. possible_key: 预测使用到的索引，参考价值
   6. key: 实际使用到的索引，
   7. key_len: 实际使用索引的长度。用于判断复合索引是否被完全使用。
   
               一个可变字段类型（varchar()类型），用2个字节标识
               一个不允许为null的索引---key_len :60
               一个允许为null的索引，则会使用1个字节用于标识。---key_len ：61
               如果使用多个索引，比如一个非null，一个允许null，key_len ：121
               例如：一个复合索引，name_name1_index(name,name1),其中name非null，name1允许null
                     explain select * from students where name=''; --key_len :60
                     explain select * from students where name1=''; --key_len :121 (复合索引是层级关系，查过第一个索引才会到第二个。)
           注意：utf8：一个字符3个字节
                 gbk：一个字符2个字节
                 latin：一个字符1个字节
                     
   8. ref: 指明表之间的引用，可以是字段也可以是const常量（注意与type中的ref值区分）
   9. rows: 通过索引优化查询到的数据量
   10. Extra: 额外优化信息
              1) using  filesort:表示 性能消耗大，需要额外的一次排序（查询）,常见于order by
              
              复合索引：不能跨列，where和order by按照复合索引的顺序使用，不要跨列或无序使用
              例如：alter table test1 add index idx_a1_a2_a3 (a1,a2,a3);
                  explain select * from test1 where a1='' order by a2;
                  explain select * from test1 where a1='' order by a3;--using  filesort
                  explain select * from test1 where a2='' order by a3;--using  filesort
              
              2) using temporary: 性能损耗大，需要额外。一般出现在group by语句中。
                 查询哪些列，就用那些列分组。
                 
                 
                 解析过程：from ...on...join..where....group by....having....select dinstinct ...order by linit...
                 
              

